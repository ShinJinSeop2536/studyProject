관계설정 책임의 분리   
UserDao가 인터 헤이스뿐 아니라 구체적인 클래스를 알아야 하는 문제가 발생  
여전히 UserDao애는 어떤 ConnextionMaker 구현 클래스를 사용할지를 결정하는 코드가 남아 있다.  
UserDao 변경 없이는 DB 커넥션 기능의 확장이 자유롭지 못한다.  
그 이유는 UserDao 안에 분리되지 않은,  또 다른 관심사항이 존재하고 있다.  
UserDao안의 new DConnectionMaker()라는 코드는 DB 커넥션을 어떻게 가졍올 것인가라는 관심사도 아니다.   
new DConnectionMaker() 독립적인 관심사를 담고 있다.  
UserDao가 어떤 ConnectionMaker 구현 클래스의 오브젝트를 이용하게 할지 결정하는 것이다.   
즉 특정 구현 클래스 사이의 관계를 설정해주는 것에 관한 관심이다. 분리 허지 않으면 결코 독립적으로 확장 가능한 클래스가 될 수 없다.  
사용되는 오브젝트를 서비스(UserDao), 사용하는 오브젝트를 클라이언트라고 부를 수 있다.  
UserDao의 클라이언트 오브젝트가 바로 제3의 관심사항인UserDao와 ConnectionMaker 구현 클래스의 관계를 결정해준느 기능을 분리해 준다.  
클래스 사이에 관계가 만들어진다는 것은 한 클래스가 인터페이스 없이 다른 클래스를 직접 사용한다는 뜻이다.  
connectionMaker = new DConnectionMaker() -> 사용이라는 관계를 맺게 해준다.(직접 생성자를 호출하는 방법)  
호출 방법은 직접 생성자를 호출해서, 외부에서 만들어 준 것을 거져오는 방법  
이 오브젝트를 꼭 UserDao의 코드 내에서 만들 필요는 없다. 오브젝트는 얼마든지 메소드 파라미터 등을 이용해 외부에서 만든걸 가져올수도 있다.  
파라미터의 타입을 전달받을 오브젝트의 인터페이스로 선언 했다면 제공받은 오브젝트는 인터페이스에 정의된 메소드만 이용하면 된다.   
UserDao 오브젝트가 동작하려면 특정 클래스의 오브젝트와 관계를 맺어야 한다.   
하지만 클래스 사이의 관계가 만들어진 것은 아니고, 단지 다이내믹한 관계가 만들어지는 것이다. 이 차이를 자 구분할 수 있어야 한다.  
클래스 사이의 관계는 코드에 다른 클래스 이름이 나타나기 때문에 만들어지는 것이다.   
하지만 오브젝트 사이의 관계는 그렇지 않다.   
특정 클래스를 전혀 알지 못하더라도 해당 클래스가 수현한 인터페이스를 사용했다면, 클래스의 오브젝트를 인테페이스 타입으로 받아서 사용할 수 있다.   
바로 객체지향 프로그램에는 다형성이라는 특징이다.  
UserDao 오브젝트가 DConnectionMaker 오브젝트를 사용하게 하려면 두 클래스의 오브젝트 사이에 런타임 사용관계 또는 링크,   
또틑 의존관례라고 불리는 관계를 맺어주면 된다.  
클라이언트 구조의 클래스들을 이용해 런타임 오브젝트 관계를 갖는 구조로 만들어주는 게 바로 클라이언트의 책임이다.  

